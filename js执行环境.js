
/*


    js运行

    浏览器会在计算机内存中分配一块内存，专门供代码执行的栈内存


    1.生成一个执行环境栈（ECStack),同时也会创建一个全局对象 GO（globol object），将内置的方法放在一块单独的堆内存空间中，并使用window指向全局对象



    2.生成一个全局的执行上下文EC（G），创建完成后进入到栈内存中（进栈），在当前全局执行上下文中，因为会创建很多变量赋值，所有会创建一个变量对象VO（Variable Object）来进行保存

    
    3.函数私有上下文中的变量对象叫做活动对象AO（Activation Object），函数具有作用域和作用域链，作用域则是在函数创建的时候就具备的，在全局中创建一个函数，那函数的作用域就是全局执行上下文，也就是VO（G），当函数被调用的时候，会创建一个新的执行上下文，然后其作用域链通过作用域把函数的AO链接到VO上，当寻找变量时，先从自身的AO中找，如果找不到，再到父级的AO中找，函数的aguments也属于私有变量。创建一个函数的私有执行上文后，需要进入栈中去执行，此时，执行栈中的全局执行上下文就会被压入到栈底



    在栈中创建变量赋值 var a = 4 分为三步

            1.先创建一个值4
            2.再创建一个变量a
            3.把a指向4

     值又分为基本类型值和引用类型值，当创建基本类型值是在栈中创建的，而创建引用值会开辟一块新的堆内存，存他的16位进制的地址，然后保存在栈中，变量则指向地址。
     
     

    内存泄露：
    程序的运行需要内存，持续运行的服务进程，必须及时释放内存，否则内存占用越来越高，会影响性能，重则导致进程崩溃
    不再用到的内存，没有及时释放，就叫做内存泄露




    js会有垃圾回收机制

    js中最常用的垃圾回收方式就是标记清楚，当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为"进入环境"，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为"离开环境"。


    function test(){
        var a = 10;    //被标记"进入环境"
        var b = "hello";    //被标记"进入环境"
    }
    test();    //执行完毕后之后，a和b又被标记"离开环境"，被回收

    垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去掉处在环境中的变量及被环境中的变量引用的变量标记（闭包）。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。


    所以闭包  当子函数在父函数中，运行子函数会把子函数执行上下文中的作用域链接到父函数中，当访问父函数的变量并且发生改变时，因为时一个指向，所以父函数的变量也会发生改变，根据垃圾回收的机制，它去掉了被子函数环境中变量引用的变量标记，所以会形成闭包，而且变量不会被回收。


    函数创建的时候体内会保存创建时的文本环境,函数调用创建一个全局上下文，会以他体内保存的哪个文本环境为父，在其文本环境找变量，找不到就去父级文本环境找，就构成了作用域链。
    函数是根据创建嵌套关系形成作用域链，也就是函数的书写位置形成作用域链，因此称词法作用域。









*/