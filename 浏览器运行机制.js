/*

一、浏览器输入url，由主进程接管，开启一个下载进程
    1.浏览器是多进程的，包含的有Browser进程（负责协调、主控，只有一个）、第三方插件进程（每种类型的插件对应一个进程，仅当使用该插件时才创建）、GPU进程（最多一个，用于3D绘制等）、浏览器渲染进程（renderer进程，浏览器内核，默认每个Tab页一个进程，互不影响，主要是用于页面渲染，脚本执行、事件处理等）
    2.浏览器渲染进程下有多个线程，分别为：

      GUI渲染线程：负责渲染浏览器页面，解析HTML/CSS,构建DOM树和渲染树，布局和绘制，当页面重绘或者回流，该线程执行，和JS引擎互斥，JS引擎运行则挂起（冻结），GUI更新会保存在一个队列里等JS引擎空闲再执行

      JS引擎线程：负责处理JS脚本

      事件触发线程：归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）

      定时器触发线程：传说中的setInterval与setTimeout所在线程
      浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

      异步HTTP请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求


      如果有非常耗时的工作，单独开一个work线程，子线程是浏览器开的，完全受  主线程控制，而且不能操作DOM


      JS引擎是单线程的



      浏览器渲染流程

      是等到http请求获取内容后通过renderHost接口转交给Renderer进程，然后开始渲染


      1.解析html建立Dom树
      2.解析CSS构建render树（将CSS代码解析成树形的数据结构，然后结合DOM形成render树）
      3.布局render树，负责尺寸、位置的计算
      4.绘制render树，绘制页面像素信息
      5.浏览器会将各层的信息发送给GPU，GPU进程会将各层合成



      JS的运行机制

      JS分为同步任务和异步任务
      同步任务都在主线程（JS引擎线程）上执行，形成一个执行栈
      主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件
      一旦执行栈中所有同步任务执行完毕（此时JS引擎空闲，系统就会读取任务队列），可将隐形的异步任务添加到可执行栈中，开始执行


      定时器则是由定时器线程执行的，因为JS引擎是单线程的，如果处于阻塞状态就会影响定时器的准备，所有单独开一个线程来计时


      etTimeout中低于4ms的时间间隔算为4ms


      事件循环进阶 ：  JS中分为两种任务类型  
     macrotask（宏任务、task）：可以理解每次执行栈执行的代码就是一个宏任务

     每一个宏任务会从头到尾将这个任务执行完毕，不会执行其它

     浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染

     microtask（微任务、jobs）：可以理解为当前task执行结束后立即执行的任务
      
     也就是说，在当前task任务后，下一个task前，在渲染之前
     所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
     也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

     再根据线程来理解下:
      
        宏任务的事件都是放在一个事件队列中，是在事件触发线程中维护
        
        微任务中所有的微任务都是添加到微任务队列中，等待当前的宏任务执行完毕后执行，而这个队列由JS引擎线程维护

        （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）


     执行一个宏任务（栈中没有就从事件队列中获取）
     执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
     宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
     当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
     渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）


 二、开启网络线程到发出一个完整的http请求


    域名组成部分：协议头，域名，端口号，目录、参数、#后面hash（定位到某个位置）


    开启网络线程发送一个完整的http请求
    1,DNS查询域名
    将域名解析成ip地址


    2，tcp/ip请求

    三次握手


    五层的因特网

    1.应用层，DNS解析成IP并发送网络请求

    2.传输层，建立tcp连接（三次握手）

    3.网络层，IP寻址

    4.数据链路层，封装成帧

    5.物理层，物理传输（利用物理介质传输比特流，然后传输的时候通过双绞线，电磁波等各种介质）




    3.后台和前台的http交互


    前后端交互时，报文作为信息的载体

    http报文结构：

    通用头：request url（请求地址），request method（请求方式，get、post等），status code（返回状态吗），remote address（请求的远程服务器地址  会转成ip）

    200——表明该请求被成功地完成，所请求的资源发送回客户端
    304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
    400——客户端请求有错（譬如可以是安全模块拦截）
    401——请求未经授权
    403——禁止访问（譬如可以是未登录时禁止）
    404——资源未找到
    500——服务器内部错误
    503——服务不可用
    状态码：1xx：已接受，继续处理处理
            2xx：成功
            3xx：重定向，需要完成请求必须进行更进一步的操作
            4xx：客户端错误，请求语法有错误或者无法实现
            5xx：服务器错误



    请求/响应头：



    请求/响应体：请求实体中会将一些需要的参数都放入进入（用于post请求）。而一般响应实体中，就是放服务端需要传给客户端的内容


    在登录的时候，服务器会生成一个session，session又用户的用户名、密码等，然后会有一个sessionId，然后服务器在登录页面写入cookie，就是jsessionid=xxx；然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。


    长连接与短连接


    长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）

    短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

    http1.0默认短连接


    http1.1默认使用长连接，使用长连接会有connection：keep-alive

     keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效

    http1.1每请求一个资源，就要开启一个tcp/ip连接

    http2.0一个tcp/ip请求可以请求多个资源


    https：https就是安全版本的http
    区别就是在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法轻易被截取分析

    前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的


    强缓存（200 from cache）：浏览器如果判断本地缓存未过期，就直接使用，无需发送http请求

    弱缓存（304）：浏览器会向服务器发送http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存


    4，浏览器渲染页面




    5，最后tcp/ip 4次挥手 连接结束

    



    JS引擎解析过程


    1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）

    2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）

    3. 使用翻译器（translator），将代码转为字节码（bytecode）

    4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码





*/